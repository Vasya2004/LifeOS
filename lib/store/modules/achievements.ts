// ============================================
// ACHIEVEMENTS MODULE - Local Storage Store
// ============================================

import { mutate } from "swr"
import { getCurrentUserId } from "@/lib/auth/user-id"
import { getStore, setStore } from "../utils/storage"
import { genId } from "../utils/id"
import { now, today } from "../utils/date"
import { addXp, addCoins } from "@/lib/store/gamification"
import { addToQueue } from "@/lib/sync/offline-first"
import type {
  Achievement,
  AchievementCollection,
  AchievementStats,
  CreateAchievementInput,
  UpdateAchievementInput,
  AchievementType,
  AchievementFilters,
  AchievementSort
} from "@/lib/types/achievements"

// Coins awarded per achievement type
const ACHIEVEMENT_COINS: Record<AchievementType, number> = {
  micro: 10,
  macro: 50,
  breakthrough: 100,
  moment: 20,
}

const KEYS = {
  achievements: "achievements",
  collections: "achievement_collections",
  stats: "achievement_stats",
}

// ============================================
// DEFAULT DATA
// ============================================

const defaultCollections: Omit<AchievementCollection, "id" | "userId">[] = [
  { name: "Все достижения", description: "Все ваши победы в одном месте", icon: "trophy", color: "#6366f1", isDefault: true, sortOrder: 0, createdAt: now() },
  { name: "Избранное", description: "Особо значимые достижения", icon: "heart", color: "#ec4899", isDefault: true, sortOrder: 1, createdAt: now() },
  { name: "Капсулы времени", description: "Достижения с отложенным открытием", icon: "clock", color: "#f59e0b", isDefault: true, sortOrder: 2, createdAt: now() },
  { name: "Микро-победы", description: "Маленькие, но важные шаги", icon: "zap", color: "#22c55e", isDefault: true, sortOrder: 3, createdAt: now() },
  { name: "Прорывы", description: "Преодоление страхов и лимитов", icon: "star", color: "#8b5cf6", isDefault: true, sortOrder: 4, createdAt: now() },
]

const defaultStats: Omit<AchievementStats, "id" | "userId"> = {
  totalCount: 0,
  microCount: 0,
  macroCount: 0,
  breakthroughCount: 0,
  momentCount: 0,
  favoriteCount: 0,
  timeCapsuleCount: 0,
  timeCapsuleUnlockedCount: 0,
  currentStreakDays: 0,
  longestStreakDays: 0,
}

// ============================================
// ACHIEVEMENTS CRUD
// ============================================

export function getAchievements(): Achievement[] {
  return getStore<Achievement[]>(KEYS.achievements, [])
}

export function getAchievementById(id: string): Achievement | undefined {
  return getAchievements().find(a => a.id === id)
}

export function createAchievement(input: CreateAchievementInput): Achievement {
  const achievements = getAchievements()
  
  const achievementId = genId()
  const newAchievement: Achievement = {
    id: achievementId,
    userId: getCurrentUserId(),
    ...input,
    mediaUrls: input.mediaUrls || [],
    coverImageIndex: 0,
    isAutoGenerated: false,
    isTimeCapsule: input.isTimeCapsule || false,
    isFavorite: input.isFavorite || false,
    isPrivate: input.isPrivate !== false,
    xpAwarded: calculateXpForAchievement(input.type),
    badgeIcon: getBadgeIconForType(input.type),
    badgeColor: getBadgeColorForType(input.type),
    createdAt: now(),
    links: input.links?.map(link => ({
      id: genId(),
      achievementId,
      userId: getCurrentUserId(),
      ...link,
      createdAt: now(),
    })) || [],
  }
  
  setStore(KEYS.achievements, [...achievements, newAchievement])
  
  // Update stats
  updateStatsForNewAchievement(input.type)
  
  // Add to collections
  if (input.collectionIds?.length) {
    addToCollections(newAchievement.id, input.collectionIds)
  }

  // Award XP and coins
  addXp(newAchievement.xpAwarded, "achievement_created")
  addCoins(ACHIEVEMENT_COINS[input.type])

  // Queue for server sync
  addToQueue({ table: "achievements", operation: "insert", recordId: achievementId, data: newAchievement as unknown as Record<string, unknown> })

  mutate(KEYS.achievements)
  return newAchievement
}

export function updateAchievement(input: UpdateAchievementInput): Achievement | null {
  const achievements = getAchievements()
  const index = achievements.findIndex(a => a.id === input.id)
  
  if (index === -1) return null
  
  const updated: Achievement = {
    ...achievements[index],
    ...input,
    updatedAt: now(),
    links: input.links?.map(link => ({
      id: genId(),
      achievementId: input.id,
      userId: getCurrentUserId(),
      ...link,
      createdAt: now(),
    })) || achievements[index].links,
  }
  
  setStore(KEYS.achievements, [
    ...achievements.slice(0, index),
    updated,
    ...achievements.slice(index + 1),
  ])

  addToQueue({ table: "achievements", operation: "update", recordId: input.id, data: updated as unknown as Record<string, unknown> })

  mutate(KEYS.achievements)
  return updated
}

export function deleteAchievement(id: string): boolean {
  const achievements = getAchievements()
  const exists = achievements.some(a => a.id === id)
  
  if (!exists) return false
  
  setStore(KEYS.achievements, achievements.filter(a => a.id !== id))

  addToQueue({ table: "achievements", operation: "delete", recordId: id })

  mutate(KEYS.achievements)

  // Recalculate stats
  recalculateStats()
  
  return true
}

export function toggleFavorite(id: string): boolean {
  const achievement = getAchievementById(id)
  if (!achievement) return false
  
  updateAchievement({ id, isFavorite: !achievement.isFavorite })
  
  // Update favorite count in stats
  const stats = getStats()
  const favoriteDelta = !achievement.isFavorite ? 1 : -1
  setStore(KEYS.stats, {
    ...stats,
    favoriteCount: Math.max(0, stats.favoriteCount + favoriteDelta),
  })
  mutate(KEYS.stats)
  
  return true
}

// ============================================
// FILTER & SORT
// ============================================

export function filterAchievements(
  achievements: Achievement[],
  filters: AchievementFilters
): Achievement[] {
  return achievements.filter(a => {
    // Type filter
    if (filters.types?.length && !filters.types.includes(a.type)) {
      return false
    }
    
    // Category filter
    if (filters.categories?.length && (!a.category || !filters.categories.includes(a.category))) {
      return false
    }
    
    // Date range
    if (filters.dateFrom && a.achievementDate < filters.dateFrom) {
      return false
    }
    if (filters.dateTo && a.achievementDate > filters.dateTo) {
      return false
    }
    
    // Favorite filter
    if (filters.isFavorite && !a.isFavorite) {
      return false
    }
    
    // Time capsule filter
    if (filters.isTimeCapsule && !a.isTimeCapsule) {
      return false
    }
    
    // Search query
    if (filters.searchQuery) {
      const query = filters.searchQuery.toLowerCase()
      const matchesTitle = a.title.toLowerCase().includes(query)
      const matchesDesc = a.description?.toLowerCase().includes(query)
      if (!matchesTitle && !matchesDesc) {
        return false
      }
    }
    
    // Collection filter (would need to check collection items)
    if (filters.collectionId) {
      // TODO: Implement collection filtering
    }
    
    return true
  })
}

export function sortAchievements(
  achievements: Achievement[],
  sort: AchievementSort
): Achievement[] {
  return [...achievements].sort((a, b) => {
    let comparison = 0
    
    switch (sort.field) {
      case "date":
        comparison = new Date(a.achievementDate).getTime() - new Date(b.achievementDate).getTime()
        break
      case "title":
        comparison = a.title.localeCompare(b.title)
        break
      case "type":
        comparison = a.type.localeCompare(b.type)
        break
      case "created":
        comparison = new Date(a.createdAt).getTime() - new Date(b.createdAt).getTime()
        break
    }
    
    return sort.direction === "desc" ? -comparison : comparison
  })
}

// ============================================
// COLLECTIONS
// ============================================

export function getCollections(): AchievementCollection[] {
  const collections = getStore<AchievementCollection[]>(KEYS.collections, [])
  
  // Initialize default collections if empty
  if (collections.length === 0) {
    const newCollections: AchievementCollection[] = defaultCollections.map((c, i) => ({
      ...c,
      id: genId(),
      userId: getCurrentUserId(),
      createdAt: now(),
    }))
    setStore(KEYS.collections, newCollections)
    return newCollections
  }
  
  return collections
}

export function createCollection(
  name: string, 
  description?: string, 
  icon: string = "folder",
  color: string = "#6366f1"
): AchievementCollection {
  const collections = getCollections()
  const maxOrder = Math.max(...collections.map(c => c.sortOrder), 0)
  
  const newCollection: AchievementCollection = {
    id: genId(),
    userId: getCurrentUserId(),
    name,
    description,
    icon,
    color,
    isDefault: false,
    sortOrder: maxOrder + 1,
    createdAt: now(),
  }
  
  setStore(KEYS.collections, [...collections, newCollection])
  mutate(KEYS.collections)
  return newCollection
}

export function addToCollections(achievementId: string, collectionIds: string[]): void {
  // TODO: Implement collection items linking
}

// ============================================
// STATS
// ============================================

export function getStats(): AchievementStats {
  return getStore<AchievementStats>(KEYS.stats, {
    id: genId(),
    userId: getCurrentUserId(),
    ...defaultStats,
  })
}

function updateStatsForNewAchievement(type: AchievementType): void {
  const stats = getStats()
  
  const updates: Partial<AchievementStats> = {
    totalCount: stats.totalCount + 1,
  }
  
  switch (type) {
    case "micro":
      updates.microCount = stats.microCount + 1
      break
    case "macro":
      updates.macroCount = stats.macroCount + 1
      break
    case "breakthrough":
      updates.breakthroughCount = stats.breakthroughCount + 1
      break
    case "moment":
      updates.momentCount = stats.momentCount + 1
      break
  }
  
  // Update streak
  const todayStr = today()
  if (stats.lastAchievementDate) {
    const lastDate = new Date(stats.lastAchievementDate)
    const todayDate = new Date(todayStr)
    const diffDays = Math.floor((todayDate.getTime() - lastDate.getTime()) / (1000 * 60 * 60 * 24))
    
    if (diffDays === 1) {
      updates.currentStreakDays = stats.currentStreakDays + 1
      updates.longestStreakDays = Math.max(stats.longestStreakDays, updates.currentStreakDays)
    } else if (diffDays > 1) {
      updates.currentStreakDays = 1
    }
  } else {
    updates.currentStreakDays = 1
    updates.longestStreakDays = 1
  }
  
  updates.lastAchievementDate = todayStr
  
  setStore(KEYS.stats, { ...stats, ...updates })
  mutate(KEYS.stats)
}

function recalculateStats(): void {
  const achievements = getAchievements()
  
  const stats: AchievementStats = {
    id: getStats().id,
    userId: getCurrentUserId(),
    totalCount: achievements.length,
    microCount: achievements.filter(a => a.type === "micro").length,
    macroCount: achievements.filter(a => a.type === "macro").length,
    breakthroughCount: achievements.filter(a => a.type === "breakthrough").length,
    momentCount: achievements.filter(a => a.type === "moment").length,
    favoriteCount: achievements.filter(a => a.isFavorite).length,
    timeCapsuleCount: achievements.filter(a => a.isTimeCapsule).length,
    timeCapsuleUnlockedCount: achievements.filter(a => a.isTimeCapsule && a.unlockDate && new Date(a.unlockDate) <= new Date()).length,
    currentStreakDays: calculateCurrentStreak(achievements),
    longestStreakDays: calculateLongestStreak(achievements),
    lastAchievementDate: achievements.length > 0 
      ? achievements.sort((a, b) => new Date(b.achievementDate).getTime() - new Date(a.achievementDate).getTime())[0].achievementDate
      : undefined,
  }
  
  setStore(KEYS.stats, stats)
  mutate(KEYS.stats)
}

function calculateCurrentStreak(achievements: Achievement[]): number {
  if (achievements.length === 0) return 0
  
  const sortedDates = [...new Set(achievements.map(a => a.achievementDate))].sort().reverse()
  const todayStr = today()
  
  let streak = 0
  let expectedDate = new Date(todayStr)
  
  for (const dateStr of sortedDates) {
    const date = new Date(dateStr)
    const diffDays = Math.floor((expectedDate.getTime() - date.getTime()) / (1000 * 60 * 60 * 24))
    
    if (diffDays === 0 || (streak === 0 && diffDays === 1)) {
      streak++
      expectedDate = new Date(date)
      expectedDate.setDate(expectedDate.getDate() - 1)
    } else if (diffDays > 1) {
      break
    }
  }
  
  return streak
}

function calculateLongestStreak(achievements: Achievement[]): number {
  if (achievements.length === 0) return 0
  
  const sortedDates = [...new Set(achievements.map(a => a.achievementDate))].sort()
  
  let maxStreak = 1
  let currentStreak = 1
  
  for (let i = 1; i < sortedDates.length; i++) {
    const prev = new Date(sortedDates[i - 1])
    const curr = new Date(sortedDates[i])
    const diffDays = Math.floor((curr.getTime() - prev.getTime()) / (1000 * 60 * 60 * 24))
    
    if (diffDays === 1) {
      currentStreak++
      maxStreak = Math.max(maxStreak, currentStreak)
    } else {
      currentStreak = 1
    }
  }
  
  return maxStreak
}

// ============================================
// HELPERS
// ============================================

function calculateXpForAchievement(type: AchievementType): number {
  switch (type) {
    case "micro": return 25
    case "macro": return 100
    case "breakthrough": return 200
    case "moment": return 50
    default: return 25
  }
}

function getBadgeIconForType(type: AchievementType): string {
  switch (type) {
    case "micro": return "zap"
    case "macro": return "trophy"
    case "breakthrough": return "star"
    case "moment": return "sparkles"
    default: return "award"
  }
}

function getBadgeColorForType(type: AchievementType): string {
  switch (type) {
    case "micro": return "#22c55e"
    case "macro": return "#8b5cf6"
    case "breakthrough": return "#8b5cf6"
    case "moment": return "#f59e0b"
    default: return "#6366f1"
  }
}

// ============================================
// SAMPLE DATA
// ============================================

export function createSampleAchievements(): void {
  const existing = getAchievements()
  if (existing.length > 0) return
  
  const sampleAchievements: CreateAchievementInput[] = [
    {
      title: "Закончил курс по TypeScript",
      description: "Прошел полный курс с сертификатом",
      category: "skill",
      type: "macro",
      achievementDate: "2024-01-15",
      emotionTag: "proud",
      lessonLearned: "Систематическое обучение дает результаты",
    },
    {
      title: "Пробежал 5 км без остановки",
      description: "Впервые в жизни!",
      category: "health",
      type: "breakthrough",
      achievementDate: "2024-01-20",
      emotionTag: "excited",
      lessonLearned: "Главное - начать и не сдаваться",
    },
    {
      title: "Проснулся без будильника",
      description: "Ровно в 6:30, как и планировал",
      category: "health",
      type: "micro",
      achievementDate: today(),
      emotionTag: "grateful",
    },
    {
      title: "Закат на пляже",
      description: "Случайно оказался на берегу и увидел невероятный закат",
      category: "personal",
      type: "moment",
      achievementDate: "2024-02-10",
      emotionTag: "joyful",
    },
    {
      title: "Закрыл важный проект",
      description: "Клиент доволен, все в срок",
      category: "work",
      type: "macro",
      achievementDate: "2024-02-01",
      emotionTag: "relieved",
      lessonLearned: "Планирование - ключ к успеху",
    },
  ]
  
  sampleAchievements.forEach(a => createAchievement(a))
}
