// ============================================
// HABITS
// ============================================

import type { Habit } from "@/lib/types"
import { getStore, setStore, KEYS, mutateKey, genId, now } from "./core"
import { addXp, updateStats, getStats } from "./gamification"
import { addToQueue } from "@/lib/sync/offline-first"
import { createAchievement } from "@/lib/store/modules/achievements"

const STREAK_MILESTONES = [7, 14, 30, 100]

export function getHabits(): Habit[] {
  return getStore(KEYS.habits, [])
}

export function getHabitById(id: string): Habit | undefined {
  return getHabits().find(h => h.id === id)
}

export function addHabit(habit: Omit<Habit, "id" | "streak" | "bestStreak" | "totalCompletions" | "entries">) {
  const habits = getHabits()
  const newHabit: Habit = {
    ...habit,
    id: genId(),
    streak: 0,
    bestStreak: 0,
    totalCompletions: 0,
    entries: [],
  }
  const updatedHabits = [...habits, newHabit]
  setStore(KEYS.habits, updatedHabits)
  mutateKey(KEYS.habits, updatedHabits)
  
  // Sync to server
  addToQueue({ 
    table: "habits", 
    operation: "insert", 
    recordId: newHabit.id, 
    data: newHabit as Record<string, unknown> 
  })
  
  return newHabit
}

export function toggleHabitEntry(habitId: string, date: string, completed: boolean) {
  const habits = getHabits()
  const habit = habits.find(h => h.id === habitId)
  if (!habit) return
  
  const entries = [...habit.entries]
  const existingIndex = entries.findIndex(e => e.date === date)
  
  if (existingIndex >= 0) {
    entries[existingIndex] = { ...entries[existingIndex], completed }
  } else {
    entries.push({ date, completed })
  }
  
  // Calculate streak
  const streak = calculateStreak(entries)
  const bestStreak = Math.max(habit.bestStreak, streak)
  const totalCompletions = entries.filter(e => e.completed).length
  
  const updatedHabit = {
    ...habit,
    entries,
    streak,
    bestStreak,
    totalCompletions
  }
  
  const updatedHabits = habits.map(h =>
    h.id === habitId ? updatedHabit : h
  )
  setStore(KEYS.habits, updatedHabits)
  mutateKey(KEYS.habits, updatedHabits)
  
  // Sync habit update
  addToQueue({ 
    table: "habits", 
    operation: "update", 
    recordId: habitId, 
    data: updatedHabit as Record<string, unknown> 
  })
  
  // Sync habit entry
  addToQueue({ 
    table: "habit_entries", 
    operation: existingIndex >= 0 ? "update" : "insert", 
    recordId: `${habitId}-${date}`, 
    data: { 
      habit_id: habitId, 
      date, 
      completed,
      user_id: null // Will be set by server
    } 
  })
  
  if (completed) {
    addXp(habit.xpReward || 10, "habit_completed")
    updateStats({ totalHabitCompletions: getStats().totalHabitCompletions + 1 })

    // Auto-achievement at streak milestones
    if (STREAK_MILESTONES.includes(streak)) {
      createAchievement({
        title: `${streak} дней подряд: ${habit.title}`,
        description: `Серия из ${streak} дней выполнения привычки`,
        type: "micro",
        achievementDate: date,
        isAutoGenerated: true,
        links: [{ sourceType: "habit", sourceId: habit.id, sourceTitle: habit.title }],
      })
    }
  }
}

export function updateHabit(id: string, updates: Partial<Habit>) {
  const habits = getHabits()
  const habit = habits.find(h => h.id === id)
  if (!habit) return
  
  const updatedHabit = { ...habit, ...updates }
  const updatedHabits = habits.map(h => h.id === id ? updatedHabit : h)
  setStore(KEYS.habits, updatedHabits)
  mutateKey(KEYS.habits, updatedHabits)
  
  // Sync to server
  addToQueue({ 
    table: "habits", 
    operation: "update", 
    recordId: id, 
    data: updatedHabit as Record<string, unknown> 
  })
}

export function deleteHabit(id: string) {
  const habits = getHabits()
  const updatedHabits = habits.filter(h => h.id !== id)
  setStore(KEYS.habits, updatedHabits)
  mutateKey(KEYS.habits, updatedHabits)
  
  // Sync to server
  addToQueue({ 
    table: "habits", 
    operation: "delete", 
    recordId: id 
  })
}

export function calculateStreak(entries: { date: string; completed: boolean }[]): number {
  const sorted = [...entries]
    .filter(e => e.completed)
    .sort((a, b) => new Date(b.date).getTime() - new Date(a.date).getTime())
  
  if (sorted.length === 0) return 0
  
  let streak = 0
  const today = new Date().toISOString().split('T')[0]
  let checkDate = new Date(today)
  
  for (const entry of sorted) {
    const entryDate = new Date(entry.date)
    const diffDays = Math.floor((checkDate.getTime() - entryDate.getTime()) / (1000 * 60 * 60 * 24))
    
    if (diffDays === streak) {
      streak++
      checkDate.setDate(checkDate.getDate() - 1)
    } else if (diffDays > streak) {
      break
    }
  }
  
  return streak
}

export function getHabitsByArea(areaId: string): Habit[] {
  return getHabits().filter(h => h.areaId === areaId)
}

export function getHabitsForDate(date: string): Habit[] {
  const dayOfWeek = new Date(date).getDay()
  return getHabits().filter(h => 
    h.targetDays.includes(dayOfWeek)
  )
}
